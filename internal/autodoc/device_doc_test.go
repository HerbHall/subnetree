package autodoc

import (
	"context"
	"encoding/json"
	"strings"
	"testing"
	"time"

	"github.com/HerbHall/subnetree/internal/testutil"
	"github.com/HerbHall/subnetree/pkg/models"
	"github.com/HerbHall/subnetree/pkg/plugin"
	"go.uber.org/zap"
)

func TestRenderDeviceDoc_FullData(t *testing.T) {
	now := time.Now().UTC()
	resolvedAt := now.Add(-1 * time.Hour)

	data := DeviceDocData{
		Device: &models.Device{
			ID:                       "dev-001",
			Hostname:                 "web-server-01",
			IPAddresses:              []string{"192.168.1.10", "10.0.0.10"},
			MACAddress:               "AA:BB:CC:DD:EE:FF",
			Manufacturer:             "Dell",
			DeviceType:               models.DeviceTypeServer,
			Status:                   models.DeviceStatusOnline,
			ClassificationConfidence: 85,
			FirstSeen:                now.Add(-30 * 24 * time.Hour),
			LastSeen:                 now,
			ParentDeviceID:           "gw-001",
			NetworkLayer:             4,
			ConnectionType:           "ethernet",
		},
		Hardware: &models.DeviceHardware{
			DeviceID:           "dev-001",
			OSName:             "Ubuntu",
			OSVersion:          "22.04",
			OSArch:             "amd64",
			CPUModel:           "Intel Xeon E5-2680 v4",
			CPUCores:           14,
			CPUThreads:         28,
			RAMTotalMB:         32768,
			PlatformType:       "bare-metal",
			SystemManufacturer: "Dell",
			SystemModel:        "PowerEdge R730",
		},
		Storage: []models.DeviceStorage{
			{Name: "sda", DiskType: "SSD", CapacityGB: 512, Interface: "SATA", Model: "Samsung 870 EVO"},
			{Name: "sdb", DiskType: "HDD", CapacityGB: 2048, Interface: "SAS", Model: "Seagate ST2000NM"},
		},
		GPUs: []models.DeviceGPU{
			{Model: "NVIDIA T4", Vendor: "NVIDIA", VRAMMB: 16384, DriverVersion: "535.104.05"},
		},
		Services: []models.DeviceService{
			{Name: "nginx", ServiceType: "web", Port: 80, Status: "running", Version: "1.24.0"},
			{Name: "postgresql", ServiceType: "database", Port: 5432, Status: "running", Version: "15.4"},
		},
		Children: []models.Device{
			{Hostname: "container-01", IPAddresses: []string{"172.17.0.2"}, DeviceType: models.DeviceTypeContainer, Status: models.DeviceStatusOnline},
		},
		Alerts: []DeviceAlert{
			{Severity: "warning", Message: "High CPU usage", TriggeredAt: now.Add(-2 * time.Hour), ResolvedAt: &resolvedAt},
			{Severity: "critical", Message: "Disk space low", TriggeredAt: now.Add(-30 * time.Minute)},
		},
		RecentChanges: []ChangelogEntry{
			{EventType: TopicDeviceUpdated, Summary: "Device updated: web-server-01", SourceModule: "recon", CreatedAt: now.Add(-1 * time.Hour)},
		},
		GeneratedAt: now,
	}

	md, err := RenderDeviceDoc(data)
	if err != nil {
		t.Fatalf("RenderDeviceDoc: %v", err)
	}

	checks := []string{
		"# web-server-01 (192.168.1.10)",
		"Server",
		"online",
		"85%",
		"AA:BB:CC:DD:EE:FF",
		"Dell",
		"## Hardware Profile",
		"Ubuntu",
		"22.04",
		"Intel Xeon E5-2680 v4",
		"32.0 GB",
		"### Storage",
		"Samsung 870 EVO",
		"### GPUs",
		"NVIDIA T4",
		"## Running Services",
		"nginx",
		"postgresql",
		"## Network Position",
		"Endpoint (Layer 4)",
		"gw-001",
		"container-01",
		"## Active Alerts",
		"High CPU usage",
		"Disk space low",
		"Active",
		"## Recent Changes",
		"Device updated: web-server-01",
		"Generated by SubNetree AutoDoc",
	}

	for _, check := range checks {
		if !strings.Contains(md, check) {
			t.Errorf("expected markdown to contain %q", check)
		}
	}
}

func TestRenderDeviceDoc_MinimalData(t *testing.T) {
	data := DeviceDocData{
		Device: &models.Device{
			ID:         "dev-002",
			Hostname:   "minimal-host",
			DeviceType: models.DeviceTypeUnknown,
			Status:     models.DeviceStatusOffline,
		},
		GeneratedAt: time.Now().UTC(),
	}

	md, err := RenderDeviceDoc(data)
	if err != nil {
		t.Fatalf("RenderDeviceDoc: %v", err)
	}

	if !strings.Contains(md, "# minimal-host") {
		t.Error("expected hostname in heading")
	}
	if !strings.Contains(md, "Unknown") {
		t.Error("expected device type label")
	}
	// Hardware section should be absent.
	if strings.Contains(md, "## Hardware Profile") {
		t.Error("hardware section should be omitted when hardware is nil")
	}
	// Services section should be absent.
	if strings.Contains(md, "## Running Services") {
		t.Error("services section should be omitted when services are empty")
	}
	// Alerts section should be absent.
	if strings.Contains(md, "## Active Alerts") {
		t.Error("alerts section should be omitted when alerts are empty")
	}
}

func TestRenderDeviceDoc_NilHardware(t *testing.T) {
	data := DeviceDocData{
		Device: &models.Device{
			ID:          "dev-003",
			Hostname:    "no-hw-host",
			IPAddresses: []string{"10.0.0.5"},
			DeviceType:  models.DeviceTypeDesktop,
			Status:      models.DeviceStatusOnline,
		},
		Services: []models.DeviceService{
			{Name: "ssh", ServiceType: "remote", Port: 22, Status: "running", Version: "9.0"},
		},
		GeneratedAt: time.Now().UTC(),
	}

	md, err := RenderDeviceDoc(data)
	if err != nil {
		t.Fatalf("RenderDeviceDoc: %v", err)
	}

	if strings.Contains(md, "## Hardware Profile") {
		t.Error("hardware section should be omitted when Hardware is nil")
	}
	if !strings.Contains(md, "## Running Services") {
		t.Error("services section should be present")
	}
	if !strings.Contains(md, "ssh") {
		t.Error("expected ssh service in output")
	}
}

func TestRenderDeviceDoc_EmptyServices(t *testing.T) {
	data := DeviceDocData{
		Device: &models.Device{
			ID:         "dev-004",
			Hostname:   "no-svc-host",
			DeviceType: models.DeviceTypeRouter,
			Status:     models.DeviceStatusOnline,
		},
		Hardware: &models.DeviceHardware{
			OSName:    "RouterOS",
			OSVersion: "7.12",
			OSArch:    "arm64",
			CPUModel:  "ARM Cortex-A72",
			CPUCores:  4,
			CPUThreads: 4,
			RAMTotalMB: 1024,
		},
		GeneratedAt: time.Now().UTC(),
	}

	md, err := RenderDeviceDoc(data)
	if err != nil {
		t.Fatalf("RenderDeviceDoc: %v", err)
	}

	if !strings.Contains(md, "## Hardware Profile") {
		t.Error("hardware section should be present")
	}
	if strings.Contains(md, "## Running Services") {
		t.Error("services section should be omitted when services are empty")
	}
}

func TestRenderDeviceDoc_WithAlerts(t *testing.T) {
	now := time.Now().UTC()
	resolved := now.Add(-10 * time.Minute)

	data := DeviceDocData{
		Device: &models.Device{
			ID:         "dev-005",
			Hostname:   "alert-host",
			DeviceType: models.DeviceTypeServer,
			Status:     models.DeviceStatusDegraded,
		},
		Alerts: []DeviceAlert{
			{Severity: "critical", Message: "Service down", TriggeredAt: now.Add(-1 * time.Hour)},
			{Severity: "warning", Message: "High latency", TriggeredAt: now.Add(-2 * time.Hour), ResolvedAt: &resolved},
		},
		GeneratedAt: now,
	}

	md, err := RenderDeviceDoc(data)
	if err != nil {
		t.Fatalf("RenderDeviceDoc: %v", err)
	}

	if !strings.Contains(md, "## Active Alerts") {
		t.Error("alerts section should be present")
	}
	if !strings.Contains(md, "Service down") {
		t.Error("expected critical alert message")
	}
	if !strings.Contains(md, "High latency") {
		t.Error("expected warning alert message")
	}
	// One active, one resolved.
	if !strings.Contains(md, "Active") {
		t.Error("expected 'Active' for unresolved alert")
	}
}

func TestRenderDeviceDoc_WithChangelog(t *testing.T) {
	now := time.Now().UTC()

	data := DeviceDocData{
		Device: &models.Device{
			ID:         "dev-006",
			Hostname:   "changelog-host",
			DeviceType: models.DeviceTypeNAS,
			Status:     models.DeviceStatusOnline,
		},
		RecentChanges: []ChangelogEntry{
			{EventType: TopicDeviceDiscovered, Summary: "New device discovered: changelog-host", SourceModule: "recon", CreatedAt: now.Add(-7 * 24 * time.Hour)},
			{EventType: TopicAlertTriggered, Summary: "Alert triggered: disk full", SourceModule: "pulse", CreatedAt: now.Add(-2 * 24 * time.Hour)},
			{EventType: TopicAlertResolved, Summary: "Alert resolved: disk full", SourceModule: "pulse", CreatedAt: now.Add(-1 * 24 * time.Hour)},
		},
		GeneratedAt: now,
	}

	md, err := RenderDeviceDoc(data)
	if err != nil {
		t.Fatalf("RenderDeviceDoc: %v", err)
	}

	if !strings.Contains(md, "## Recent Changes") {
		t.Error("changelog section should be present")
	}
	if !strings.Contains(md, "[NEW]") {
		t.Error("expected [NEW] icon for discovery event")
	}
	if !strings.Contains(md, "[ALERT]") {
		t.Error("expected [ALERT] icon for alert event")
	}
	if !strings.Contains(md, "[OK]") {
		t.Error("expected [OK] icon for resolved event")
	}
	if !strings.Contains(md, "_(via recon)_") {
		t.Error("expected source tag for recon module")
	}
}

func TestListFilter_DeviceID(t *testing.T) {
	db := testutil.NewStore(t)

	m := New()
	logger, _ := zap.NewDevelopment()
	bus := testutil.NewMockBus()

	err := m.Init(context.Background(), plugin.Dependencies{
		Logger: logger.Named("autodoc"),
		Store:  db,
		Bus:    bus,
	})
	if err != nil {
		t.Fatalf("Init: %v", err)
	}

	// Create entries for different devices.
	devA := "device-aaa"
	devB := "device-bbb"
	entries := []ChangelogEntry{
		{ID: "e1", EventType: TopicDeviceDiscovered, Summary: "Discovered A", Details: json.RawMessage("{}"), SourceModule: "recon", DeviceID: &devA, CreatedAt: time.Now().UTC().Add(-3 * time.Minute)},
		{ID: "e2", EventType: TopicDeviceUpdated, Summary: "Updated B", Details: json.RawMessage("{}"), SourceModule: "recon", DeviceID: &devB, CreatedAt: time.Now().UTC().Add(-2 * time.Minute)},
		{ID: "e3", EventType: TopicDeviceUpdated, Summary: "Updated A", Details: json.RawMessage("{}"), SourceModule: "recon", DeviceID: &devA, CreatedAt: time.Now().UTC().Add(-1 * time.Minute)},
		{ID: "e4", EventType: TopicScanCompleted, Summary: "Scan done", Details: json.RawMessage("{}"), SourceModule: "recon", CreatedAt: time.Now().UTC()},
	}
	for _, entry := range entries {
		if saveErr := m.store.SaveEntry(context.Background(), entry); saveErr != nil {
			t.Fatalf("SaveEntry: %v", saveErr)
		}
	}

	// Filter by device A.
	results, total, err := m.store.ListEntries(context.Background(), ListFilter{
		Page:     1,
		PerPage:  50,
		DeviceID: devA,
	})
	if err != nil {
		t.Fatalf("ListEntries: %v", err)
	}
	if total != 2 {
		t.Errorf("total = %d, want 2 (entries for device A)", total)
	}
	if len(results) != 2 {
		t.Errorf("results = %d, want 2", len(results))
	}
	for _, r := range results {
		if r.DeviceID == nil || *r.DeviceID != devA {
			t.Errorf("entry device_id = %v, want %q", r.DeviceID, devA)
		}
	}

	// Filter by device B.
	results, total, err = m.store.ListEntries(context.Background(), ListFilter{
		Page:     1,
		PerPage:  50,
		DeviceID: devB,
	})
	if err != nil {
		t.Fatalf("ListEntries: %v", err)
	}
	if total != 1 {
		t.Errorf("total = %d, want 1 (entries for device B)", total)
	}
	if len(results) != 1 {
		t.Errorf("results = %d, want 1", len(results))
	}
}
